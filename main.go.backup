package main

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/michimani/gotwi"
	"github.com/michimani/gotwi/fields"
	"github.com/michimani/gotwi/list/listmember"
	listType "github.com/michimani/gotwi/list/listmember/types"
	"github.com/michimani/gotwi/list/managelist"
	"github.com/michimani/gotwi/list/managelist/types"
	"github.com/michimani/gotwi/user/follow"
	followType "github.com/michimani/gotwi/user/follow/types"
	"github.com/michimani/gotwi/user/userlookup"
	userType "github.com/michimani/gotwi/user/userlookup/types"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httputil"
	"net/url"
	"strings"
	"time"
)

func main() {
	type Token struct {
		TokenType    string `json:"token_type"`
		ExpiresIn    int64  `json:"expires_in"`
		AccessToken  string `json:"access_token"`
		Scope        string `json:"scope"`
		RefreshToken string `json:"refresh_token"`
		ExpiryTime   time.Time
	}

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "static/index.html")
		reqDump, err := httputil.DumpRequest(r, true)
		if err != nil {
			log.Fatal(err)
		}

		fmt.Printf("REQUEST:\n%s", string(reqDump))

		state := r.URL.Query().Get("state")
		log.Println("Url Param 'state' is: " + string(state))

		code := r.URL.Query().Get("code")
		log.Println("Url Param 'code' is: " + string(code))

		if state != "" && code != "" {
			clientId := "QjNicG1yNHJrWXpQYmJYS0gyT006MTpjaQ"
			clientSecret := "LKc6f7UmoBPxk_srrQ18WVicIhTdWXtgJb7Chlpx1Rhck8uMaW"

			encodedClientCreds := base64.StdEncoding.EncodeToString([]byte(clientId + ":" + clientSecret))

			if err == nil {

				apiUrl := "https://api.twitter.com/2/oauth2/token"
				data := url.Values{}
				data.Set("code", code)
				data.Set("grant_type", "authorization_code")
				data.Set("redirect_uri", "https://calm-bushes-wear-49-206-116-201.loca.lt")
				data.Set("code_verifier", "challenge")

				u, err := url.ParseRequestURI(apiUrl)

				if err == nil {
					urlStr := u.String()

					client := &http.Client{}
					r, _ := http.NewRequest(http.MethodPost, urlStr, strings.NewReader(data.Encode())) // URL-encoded payload
					r.Header.Add("Authorization", "Basic "+encodedClientCreds)
					r.Header.Add("Content-Type", "application/x-www-form-urlencoded")

					resp, err := client.Do(r)

					if err == nil {
						body, err := ioutil.ReadAll(resp.Body)
						if err != nil {
							log.Fatalln(err)
						}
						//Convert the body to type string
						sb := string(body)
						log.Printf(sb)

						token := Token{}
						json.Unmarshal(body, &token)

						t := time.Now()

						if token.ExpiresIn == 7200 {
							token.ExpiryTime = t.Add(time.Second * 7200)
						} else {
							// TODO: Implement routine to know if the expiry has been changed
							log.Fatalln("Token expiry time changed")
						}

						in := &gotwi.NewClientWithAccessTokenInput{
							AccessToken: token.AccessToken,
						}

						c, err := gotwi.NewClientWithAccessToken(in)
						if err != nil {
							log.Println(err)
							getDetailedError(err)
						}

						p := &userType.GetMeInput{
							Expansions: fields.ExpansionList{
								fields.ExpansionPinnedTweetID,
							},
							UserFields: fields.UserFieldList{
								fields.UserFieldCreatedAt,
							},
							TweetFields: fields.TweetFieldList{
								fields.TweetFieldCreatedAt,
							},
						}

						u, err := userlookup.GetMe(context.Background(), c, p)

						if err == nil {

							log.Println("ID:          ", gotwi.StringValue(u.Data.ID))
							log.Println("Name:        ", gotwi.StringValue(u.Data.Name))
							log.Println("Username:    ", gotwi.StringValue(u.Data.Username))
							log.Println("CreatedAt:   ", u.Data.CreatedAt)
							if u.Includes.Tweets != nil {
								for _, t := range u.Includes.Tweets {
									log.Println("PinnedTweet: ", gotwi.StringValue(t.Text))
								}
							}

							f := &followType.ListFollowersInput{
								ID:              gotwi.StringValue(u.Data.ID),
								MaxResults:      1000,
								PaginationToken: "",
								Expansions:      nil,
								TweetFields:     nil,
								UserFields: fields.UserFieldList{
									fields.UserFieldID,
								},
							}

							followers, err := follow.ListFollowers(context.Background(), c, f)
							if err != nil {
								log.Println(err)
								return
							}

							listCreateInput := types.CreateInput{
								Name:        "EngageWithFollowers#1",
								Description: gotwi.String("A List containing my followers"),
								Private:     gotwi.Bool(true),
							}

							listCreateOutput, err := managelist.Create(context.Background(), c, &listCreateInput)

							if err == nil {
								listID := listCreateOutput.Data.ID

								log.Printf("followers: %v, listID: %s", followers, listID)

								for _, follower := range followers.Data {

									listCreateInput := &listType.CreateInput{
										ID:     listID,
										UserID: gotwi.StringValue(follower.ID),
									}

									listMemberCreateOutput, err := listmember.Create(context.Background(), c, listCreateInput)

									if err == nil {
										log.Printf("List member added %t", listMemberCreateOutput.Data.IsMember)
									} else {
										log.Println("Error adding member to the list", err)
										getDetailedError(err)
									}

								}
							} else {
								log.Println("Error creating list", err)
								getDetailedError(err)
							}

						} else {
							log.Println(err)
							getDetailedError(err)
						}

					} else {
						log.Println(err)
						getDetailedError(err)
					}

				}
			} else {
				log.Fatal(err)
			}

		}

	})

	log.Fatal(http.ListenAndServe(":8081", nil))

}

func getDetailedError(err error) {
	// more error information
	ge := err.(*gotwi.GotwiError)
	if ge.OnAPI {
		log.Println(ge.Title)
		log.Println(ge.Detail)
		log.Println(ge.Type)
		log.Println(ge.Status)
		log.Println(ge.StatusCode)

		for _, ae := range ge.APIErrors {
			log.Println(ae.Message)
			log.Println(ae.Label)
			log.Println(ae.Parameters)
			log.Println(ae.Code)
			log.Println(ae.Code.Detail())
		}

		if ge.RateLimitInfo != nil {
			log.Println(ge.RateLimitInfo.Limit)
			log.Println(ge.RateLimitInfo.Remaining)
			log.Println(ge.RateLimitInfo.ResetAt)
		}
	}
}
